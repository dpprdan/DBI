<h2 id="DBI-package">DBI: R Database Interface</h2>

<span id="topic+DBI"></span>
<span id="topic+DBI-package"></span>
<p>DBI defines an interface for communication between R and relational database
management systems.
All classes in this package are virtual and need to be extended by
the various R/DBMS implementations (so-called <em>DBI backends</em>).
</p>
<h3>Definition</h3>
<p>A DBI backend is an R package
which imports the <span class="pkg">DBI</span>
and <span class="pkg">methods</span>
packages.
For better or worse, the names of many existing backends start with
‘R’, e.g., <span class="pkg">RSQLite</span>, <span class="pkg">RMySQL</span>, <span class="pkg">RSQLServer</span>; it is up
to the backend author to adopt this convention or not.
</p>
<h3>DBI classes and methods</h3>
<p>A backend defines three classes,
which are subclasses of
DBIDriver,
DBIConnection,
and DBIResult.
The backend provides implementation for all methods
of these base classes
that are defined but not implemented by DBI.
All methods defined in <span class="pkg">DBI</span> are reexported (so that the package can
be used without having to attach <span class="pkg">DBI</span>),
and have an ellipsis <code>...</code> in their formals for extensibility.
</p>
<h3>Construction of the DBIDriver object</h3>
<p>The backend must support creation of an instance of its DBIDriver subclass
with a <dfn>constructor function</dfn>.
By default, its name is the package name without the leading ‘R’
(if it exists), e.g., <code>SQLite</code> for the <span class="pkg">RSQLite</span> package.
However, backend authors may choose a different name.
The constructor must be exported, and
it must be a function
that is callable without arguments.
DBI recommends to define a constructor with an empty argument list.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
RSQLite::SQLite()

</code></pre>
<h2 id="dbDataType">Determine the SQL data type of an object</h2>

<span id="topic+dbDataType"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbDataType(dbObj, obj, ...)
</code></pre>
<h3>Description</h3>
<p>Returns an SQL string that describes the SQL data type to be used for an
object.
The default implementation of this generic determines the SQL type of an
R object according to the SQL 92 specification, which may serve as a starting
point for driver implementations. DBI also provides an implementation
for data.frame which will return a character vector giving the type for each
column in the dataframe.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbDataType_+3A_dbobj">dbObj</code></td>
<td>
<p>A object inheriting from DBIDriver
or DBIConnection</p>
</td>
</tr>
<tr>
<td><code id="dbDataType_+3A_obj">obj</code></td>
<td>
<p>An R object whose SQL type we want to determine.</p>
</td>
</tr>
<tr>
<td><code id="dbDataType_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Details</h3>
<p>The data types supported by databases are different than the data types in R,
but the mapping between the primitive types is straightforward:
</p>
<ul>
<li>
<p> Any of the many fixed and varying length character types are mapped to
character vectors
</p>
</li>
<li>
<p> Fixed-precision (non-IEEE) numbers are mapped into either numeric or
integer vectors.
</p>
</li>
</ul>

<p>Notice that many DBMS do not follow IEEE arithmetic, so there are potential
problems with under/overflows and loss of precision.
</p>
<h3>Value</h3>
<p><code>dbDataType()</code> returns the SQL type that corresponds to the <code>obj</code> argument
as a non-empty
character string.
For data frames, a character vector with one element per column
is returned.
</p>
<h3>Failure modes</h3>
<p>An error is raised for invalid values for the <code>obj</code> argument such as a
<code>NULL</code> value.
</p>
<h3>Specification</h3>
<p>The backend can override the <code>dbDataType()</code> generic
for its driver class.
</p>
<p>This generic expects an arbitrary object as second argument.
To query the values returned by the default implementation,
run <code>example(dbDataType, package = "DBI")</code>.
If the backend needs to override this generic,
it must accept all basic R data types as its second argument, namely
logical,
integer,
numeric,
character,
dates (see Dates),
date-time (see DateTimeClasses),
and difftime.
If the database supports blobs,
this method also must accept lists of raw vectors,
and blob::blob objects.
As-is objects (i.e., wrapped by <code>I()</code>) must be
supported and return the same results as their unwrapped counterparts.
The SQL data type for factor and
ordered is the same as for character.
The behavior for other object types is not specified.
</p>
<p>All data types returned by <code>dbDataType()</code> are usable in an SQL statement
of the form
<code>"CREATE TABLE test (a ...)"</code>.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">dbDataType(ANSI(), 1:5)
dbDataType(ANSI(), 1)
dbDataType(ANSI(), TRUE)
dbDataType(ANSI(), Sys.Date())
dbDataType(ANSI(), Sys.time())
dbDataType(ANSI(), Sys.time() - as.POSIXct(Sys.Date()))
dbDataType(ANSI(), c("x", "abc"))
dbDataType(ANSI(), list(raw(10), raw(20)))
dbDataType(ANSI(), I(3))

dbDataType(ANSI(), iris)


con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbDataType(con, 1:5)
dbDataType(con, 1)
dbDataType(con, TRUE)
dbDataType(con, Sys.Date())
dbDataType(con, Sys.time())
dbDataType(con, Sys.time() - as.POSIXct(Sys.Date()))
dbDataType(con, c("x", "abc"))
dbDataType(con, list(raw(10), raw(20)))
dbDataType(con, I(3))

dbDataType(con, iris)

dbDisconnect(con)

</code></pre>
<h2 id="dbConnect">Create a connection to a DBMS</h2>

<span id="topic+dbConnect"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbConnect(drv, ...)
</code></pre>
<h3>Description</h3>
<p>Connect to a DBMS going through the appropriate authentication procedure.
Some implementations may allow you to have multiple connections open, so you
may invoke this function repeatedly assigning its output to different
objects.
The authentication mechanism is left unspecified, so check the
documentation of individual drivers for details.
Use <code>dbCanConnect()</code> to check if a connection can be established.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbConnect_+3A_drv">drv</code></td>
<td>
<p>An object that inherits from DBIDriver,
or an existing DBIConnection
object (in order to clone an existing connection).</p>
</td>
</tr>
<tr>
<td><code id="dbConnect_+3A_...">...</code></td>
<td>
<p>Authentication arguments needed by the DBMS instance; these
typically include <code>user</code>, <code>password</code>, <code>host</code>, <code>port</code>, <code>dbname</code>, etc.
For details see the appropriate <code>DBIDriver</code>.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbConnect()</code> returns an S4 object that inherits from DBIConnection.
This object is used to communicate with the database engine.
</p>
<p>A <code>format()</code> method is defined for the connection object.
It returns a string that consists of a single line of text.
</p>
<h3>Specification</h3>
<p>DBI recommends using the following argument names for authentication
parameters, with <code>NULL</code> default:
</p>
<ul>
<li> <p><code>user</code> for the user name (default: current user)
</p>
</li>
<li> <p><code>password</code> for the password
</p>
</li>
<li> <p><code>host</code> for the host name (default: local connection)
</p>
</li>
<li> <p><code>port</code> for the port number (default: local connection)
</p>
</li>
<li> <p><code>dbname</code> for the name of the database on the host, or the database file
name
</p>
</li>
</ul>

<p>The defaults should provide reasonable behavior, in particular a
local connection for <code>host = NULL</code>.  For some DBMS (e.g., PostgreSQL),
this is different to a TCP/IP connection to <code>localhost</code>.
</p>
<p>In addition, DBI supports the <code>bigint</code> argument that governs how
64-bit integer data is returned.  The following values are supported:
</p>
<ul>
<li> <p><code>"integer"</code>: always return as <code>integer</code>, silently overflow
</p>
</li>
<li> <p><code>"numeric"</code>: always return as <code>numeric</code>, silently round
</p>
</li>
<li> <p><code>"character"</code>: always return the decimal representation as <code>character</code>
</p>
</li>
<li> <p><code>"integer64"</code>: return as a data type that can be coerced using
<code>as.integer()</code> (with warning on overflow), <code>as.numeric()</code>
and <code>as.character()</code>
</p>
</li>
</ul>

<h3>Examples</h3>
<pre class="r"><code class="language-R">
# SQLite only needs a path to the database. (Here, ":memory:" is a special
# path that creates an in-memory database.) Other database drivers
# will require more details (like user, password, host, port, etc.)
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
con

dbListTables(con)

dbDisconnect(con)

# Bad, for subtle reasons:
# This code fails when RSQLite isn't loaded yet,
# because dbConnect() doesn't know yet about RSQLite.
dbListTables(con &lt;- dbConnect(RSQLite::SQLite(), ":memory:"))

</code></pre>
<h2 id="dbDisconnect">Disconnect (close) a connection</h2>

<span id="topic+dbDisconnect"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbDisconnect(conn, ...)
</code></pre>
<h3>Description</h3>
<p>This closes the connection, discards all pending work, and frees
resources (e.g., memory, sockets).
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbDisconnect_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbDisconnect_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbDisconnect()</code> returns <code>TRUE</code>, invisibly.
</p>
<h3>Failure modes</h3>
<p>A warning is issued on garbage collection when a connection has been
released without calling <code>dbDisconnect()</code>,
but this cannot be tested automatically.
At least one warning is issued immediately when calling <code>dbDisconnect()</code> on an
already disconnected
or invalid connection.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbDisconnect(con)

</code></pre>
<h2 id="dbSendQuery">Execute a query on a given database connection</h2>

<span id="topic+dbSendQuery"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbSendQuery(conn, statement, ...)
</code></pre>
<h3>Description</h3>
<p>The <code>dbSendQuery()</code> method only submits and synchronously executes the
SQL query to the database engine.  It does <em>not</em> extract any
records — for that you need to use the <code>dbFetch()</code> method, and
then you must call <code>dbClearResult()</code> when you finish fetching the
records you need.
For interactive use, you should almost always prefer <code>dbGetQuery()</code>.
Use <code>dbSendQueryArrow()</code> or <code>dbGetQueryArrow()</code> instead to retrieve the results
as an Arrow object.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbSendQuery_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbSendQuery_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td>
</tr>
<tr>
<td><code id="dbSendQuery_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Additional arguments</h3>
<p>The following arguments are not part of the <code>dbSendQuery()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>
<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li>
</ul>

<p>They must be provided as named arguments.
See the "Specification" sections for details on their usage.
</p>
<h3>Specification</h3>
<p>No warnings occur under normal conditions.
When done, the DBIResult object must be cleared with a call to
<code>dbClearResult()</code>.
Failure to clear the result set leads to a warning
when the connection is closed.
</p>
<p>If the backend supports only one open result set per connection,
issuing a second query invalidates an already open result set
and raises a warning.
The newly opened result set is valid
and must be cleared with <code>dbClearResult()</code>.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code>dbBind()</code> for details.
</p>
<h3>Specification for the <code>immediate</code> argument</h3>
<p>The <code>immediate</code> argument supports distinguishing between "direct"
and "prepared" APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the "direct" API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>
<ol>
<li>
<p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed: query is executed
</p>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed:
</p>

<ol>
<li>
<p> simple query: query is executed
</p>
</li>
<li>
<p> "special" query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li>
</ol>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code>dbBind()</code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>

<h3>Details</h3>
<p>This method is for <code>SELECT</code> queries only.  Some backends may
support data manipulation queries through this method for compatibility
reasons.  However, callers are strongly encouraged to use
<code>dbSendStatement()</code> for data manipulation statements.
</p>
<p>The query is submitted to the database server and the DBMS executes it,
possibly generating vast amounts of data. Where these data live
is driver-specific: some drivers may choose to leave the output on the server
and transfer them piecemeal to R, others may transfer all the data to the
client – but not necessarily to the memory that R manages. See individual
drivers' <code>dbSendQuery()</code> documentation for details.
</p>
<h3>Value</h3>
<p><code>dbSendQuery()</code> returns
an S4 object that inherits from DBIResult.
The result set can be used with <code>dbFetch()</code> to extract records.
Once you have finished using a result, make sure to clear it
with <code>dbClearResult()</code>.
</p>
<h3>The data retrieval flow</h3>
<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code>dbBind()</code> or <code>dbBindArrow()</code>,
is implemented by <code>dbGetQuery()</code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendQuery()</code> to create a result set object of class
DBIResult.
</p>
</li>
<li>
<p> Optionally, bind query parameters with <code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbColumnInfo()</code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li>
<p> Use <code>dbFetch()</code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li>
<p> Use <code>dbHasCompleted()</code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li>
<p> Repeat the last four steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>An error is raised when issuing a query over a closed
or invalid connection,
or if the query is not a non-<code>NA</code> string.
An error is also raised if the syntax of the query is invalid
and all query parameters are given (by passing the <code>params</code> argument)
or the <code>immediate</code> argument is set to <code>TRUE</code>.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(rs)
dbClearResult(rs)

# Pass one set of values with the param argument:
rs &lt;- dbSendQuery(
  con,
  "SELECT * FROM mtcars WHERE cyl = ?",
  params = list(4L)
)
dbFetch(rs)
dbClearResult(rs)

# Pass multiple sets of values with dbBind():
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = ?")
dbBind(rs, list(6L))
dbFetch(rs)
dbBind(rs, list(8L))
dbFetch(rs)
dbClearResult(rs)

dbDisconnect(con)

</code></pre>
<h2 id="dbFetch">Fetch records from a previously executed query</h2>

<span id="topic+dbFetch"></span>
<span id="topic+fetch"></span>
<p>This section describes the behavior of the following methods:</p>
<pre class="r"><code class="language-R">dbFetch(res, n = -1, ...)

fetch(res, n = -1, ...)
</code></pre>
<h3>Description</h3>
<p>Fetch the next <code>n</code> elements (rows) from the result set and return them
as a data.frame.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbFetch_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult,
created by <code>dbSendQuery()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbFetch_+3A_n">n</code></td>
<td>
<p>maximum number of records to retrieve per fetch. Use <code>n = -1</code>
or <code>n = Inf</code>
to retrieve all pending records.  Some implementations may recognize other
special values.</p>
</td>
</tr>
<tr>
<td><code id="dbFetch_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Details</h3>
<p><code>fetch()</code> is provided for compatibility with older DBI clients - for all
new code you are strongly encouraged to use <code>dbFetch()</code>. The default
implementation for <code>dbFetch()</code> calls <code>fetch()</code> so that it is compatible with
existing code. Modern backends should implement for <code>dbFetch()</code> only.
</p>
<h3>Value</h3>
<p><code>dbFetch()</code> always returns a data.frame with
as many rows as records were fetched and as many
columns as fields in the result set,
even if the result is a single value
or has one
or zero rows.
Passing <code>n = NA</code> is supported and returns an arbitrary number of rows (at least one)
as specified by the driver, but at most the remaining rows in the result set.
</p>
<h3>The data retrieval flow</h3>
<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code>dbBind()</code> or <code>dbBindArrow()</code>,
is implemented by <code>dbGetQuery()</code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendQuery()</code> to create a result set object of class
DBIResult.
</p>
</li>
<li>
<p> Optionally, bind query parameters with <code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbColumnInfo()</code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li>
<p> Use <code>dbFetch()</code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li>
<p> Use <code>dbHasCompleted()</code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li>
<p> Repeat the last four steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>An attempt to fetch from a closed result set raises an error.
If the <code>n</code> argument is not an atomic whole number
greater or equal to -1 or Inf, an error is raised,
but a subsequent call to <code>dbFetch()</code> with proper <code>n</code> argument succeeds.
</p>
<p>Calling <code>dbFetch()</code> on a result set from a data manipulation query
created by <code>dbSendStatement()</code> can
be fetched and return an empty data frame, with a warning.
</p>
<h3>Specification</h3>
<p>Fetching multi-row queries with one
or more columns by default returns the entire result.
Multi-row queries can also be fetched progressively
by passing a whole number (integer or
numeric)
as the <code>n</code> argument.
A value of Inf for the <code>n</code> argument is supported
and also returns the full result.
If more rows than available are fetched, the result is returned in full
without warning.
If fewer rows than requested are returned, further fetches will
return a data frame with zero rows.
If zero rows are fetched, the columns of the data frame are still fully
typed.
Fetching fewer rows than available is permitted,
no warning is issued when clearing the result set.
</p>
<p>A column named <code>row_names</code> is treated like any other column.
</p>
<p>The column types of the returned data frame depend on the data returned:
</p>
<ul>
<li> <p>integer (or coercible to an integer) for integer values between -2^31 and 2^31 - 1,
with NA for SQL <code>NULL</code> values
</p>
</li>
<li> <p>numeric for numbers with a fractional component,
with NA for SQL <code>NULL</code> values
</p>
</li>
<li> <p>logical for Boolean values (some backends may return an integer);
with NA for SQL <code>NULL</code> values
</p>
</li>
<li> <p>character for text,
with NA for SQL <code>NULL</code> values
</p>
</li>
<li>
<p> lists of raw for blobs
with NULL entries for SQL NULL values
</p>
</li>
<li>
<p> coercible using <code>as.Date()</code> for dates,
with NA for SQL <code>NULL</code> values
(also applies to the return value of the SQL function <code>current_date</code>)
</p>
</li>
<li>
<p> coercible using <code>hms::as_hms()</code> for times,
with NA for SQL <code>NULL</code> values
(also applies to the return value of the SQL function <code>current_time</code>)
</p>
</li>
<li>
<p> coercible using <code>as.POSIXct()</code> for timestamps,
with NA for SQL <code>NULL</code> values
(also applies to the return value of the SQL function <code>current_timestamp</code>)
</p>
</li>
</ul>

<p>If dates and timestamps are supported by the backend, the following R types are
used:
</p>
<ul>
<li> <p>Date for dates
(also applies to the return value of the SQL function <code>current_date</code>)
</p>
</li>
<li> <p>POSIXct for timestamps
(also applies to the return value of the SQL function <code>current_timestamp</code>)
</p>
</li>
</ul>

<p>R has no built-in type with lossless support for the full range of 64-bit
or larger integers. If 64-bit integers are returned from a query,
the following rules apply:
</p>
<ul>
<li>
<p> Values are returned in a container with support for the full range of
valid 64-bit values (such as the <code>integer64</code> class of the <span class="pkg">bit64</span>
package)
</p>
</li>
<li>
<p> Coercion to numeric always returns a number that is as close as possible
to the true value
</p>
</li>
<li>
<p> Loss of precision when converting to numeric gives a warning
</p>
</li>
<li>
<p> Conversion to character always returns a lossless decimal representation
of the data
</p>
</li>
</ul>

<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)

# Fetch all results
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(rs)
dbClearResult(rs)

# Fetch in chunks
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")
while (!dbHasCompleted(rs)) {
  chunk &lt;- dbFetch(rs, 10)
  print(nrow(chunk))
}

dbClearResult(rs)
dbDisconnect(con)

</code></pre>
<h2 id="dbClearResult">Clear a result set</h2>

<span id="topic+dbClearResult"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbClearResult(res, ...)
</code></pre>
<h3>Description</h3>
<p>Frees all resources (local and remote) associated with a result set.
This step is mandatory for all objects obtained by calling
<code>dbSendQuery()</code> or <code>dbSendStatement()</code>.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbClearResult_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult.</p>
</td>
</tr>
<tr>
<td><code id="dbClearResult_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbClearResult()</code> returns <code>TRUE</code>, invisibly, for result sets obtained from
<code>dbSendQuery()</code>,
<code>dbSendStatement()</code>,
or <code>dbSendQueryArrow()</code>,
</p>
<h3>The data retrieval flow</h3>
<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code>dbBind()</code> or <code>dbBindArrow()</code>,
is implemented by <code>dbGetQuery()</code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendQuery()</code> to create a result set object of class
DBIResult.
</p>
</li>
<li>
<p> Optionally, bind query parameters with <code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbColumnInfo()</code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li>
<p> Use <code>dbFetch()</code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li>
<p> Use <code>dbHasCompleted()</code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li>
<p> Repeat the last four steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>The command execution flow</h3>
<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code>dbBindArrow()</code>,
is implemented by <code>dbExecute()</code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendStatement()</code> to create a result set object of class
DBIResult.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li>
<p> Optionally, bind query parameters with<code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbGetRowsAffected()</code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li>
<p> Repeat the last two steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>An attempt to close an already closed result set issues a warning
for <code>dbSendQuery()</code>,
<code>dbSendStatement()</code>,
and <code>dbSendQueryArrow()</code>,
</p>
<h3>Specification</h3>
<p><code>dbClearResult()</code> frees all resources associated with retrieving
the result of a query or update operation.
The DBI backend can expect a call to <code>dbClearResult()</code> for each
<code>dbSendQuery()</code> or <code>dbSendStatement()</code> call.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

rs &lt;- dbSendQuery(con, "SELECT 1")
print(dbFetch(rs))

dbClearResult(rs)
dbDisconnect(con)

</code></pre>
<h2 id="dbBind">Bind values to a parameterized/prepared statement</h2>

<span id="topic+dbBind"></span>
<span id="topic+dbBindArrow"></span>
<p>This section describes the behavior of the following methods:</p>
<pre class="r"><code class="language-R">dbBind(res, params, ...)

dbBindArrow(res, params, ...)
</code></pre>
<h3>Description</h3>
<p>For parametrized or prepared statements,
the <code>dbSendQuery()</code>, <code>dbSendQueryArrow()</code>, and <code>dbSendStatement()</code> functions
can be called with statements that contain placeholders for values.
The <code>dbBind()</code> and <code>dbBindArrow()</code> functions bind these placeholders
to actual values,
and are intended to be called on the result set
before calling <code>dbFetch()</code> or <code>dbFetchArrow()</code>.
The values are passed to <code>dbBind()</code> as lists or data frames,
and to <code>dbBindArrow()</code> as a stream
created by <code>nanoarrow::as_nanoarrow_array_stream()</code>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="https://dbi.r-dbi.org/reference/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p><code>dbBindArrow()</code> is experimental, as are the other <code style="white-space: pre;">⁠*Arrow⁠</code> functions.
<code>dbSendQuery()</code> is compatible with <code>dbBindArrow()</code>, and <code>dbSendQueryArrow()</code>
is compatible with <code>dbBind()</code>.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbBind_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult.</p>
</td>
</tr>
<tr>
<td><code id="dbBind_+3A_params">params</code></td>
<td>
<p>For <code>dbBind()</code>, a list of values, named or unnamed,
or a data frame, with one element/column per query parameter.
For <code>dbBindArrow()</code>, values as a nanoarrow stream,
with one column per query parameter.</p>
</td>
</tr>
<tr>
<td><code id="dbBind_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Details</h3>
<p><span class="pkg">DBI</span> supports parametrized (or prepared) queries and statements
via the <code>dbBind()</code> and <code>dbBindArrow()</code> generics.
Parametrized queries are different from normal queries
in that they allow an arbitrary number of placeholders,
which are later substituted by actual values.
Parametrized queries (and statements) serve two purposes:
</p>
<ul>
<li>
<p> The same query can be executed more than once with different values.
The DBMS may cache intermediate information for the query,
such as the execution plan, and execute it faster.
</p>
</li>
<li>
<p> Separation of query syntax and parameters protects against SQL injection.
</p>
</li>
</ul>

<p>The placeholder format is currently not specified by <span class="pkg">DBI</span>;
in the future, a uniform placeholder syntax may be supported.
Consult the backend documentation for the supported formats.
For automated testing, backend authors specify the placeholder syntax with
the <code>placeholder_pattern</code> tweak.
Known examples are:
</p>
<ul>
<li> <p><code style="white-space: pre;">⁠?⁠</code> (positional matching in order of appearance) in <span class="pkg">RMariaDB</span> and <span class="pkg">RSQLite</span>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠\$1⁠</code> (positional matching by index) in <span class="pkg">RPostgres</span> and <span class="pkg">RSQLite</span>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠:name⁠</code> and <code style="white-space: pre;">⁠\$name⁠</code> (named matching) in <span class="pkg">RSQLite</span>
</p>
</li>
</ul>

<h3>Value</h3>
<p><code>dbBind()</code> returns the result set,
invisibly,
for queries issued by <code>dbSendQuery()</code> or <code>dbSendQueryArrow()</code> and
also for data manipulation statements issued by
<code>dbSendStatement()</code>.
</p>
<h3>The data retrieval flow</h3>
<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code>dbBind()</code> or <code>dbBindArrow()</code>,
is implemented by <code>dbGetQuery()</code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendQuery()</code> to create a result set object of class
DBIResult.
</p>
</li>
<li>
<p> Optionally, bind query parameters with <code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbColumnInfo()</code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li>
<p> Use <code>dbFetch()</code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li>
<p> Use <code>dbHasCompleted()</code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li>
<p> Repeat the last four steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>The data retrieval flow for Arrow streams</h3>
<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as an Arrow stream.
</p>
<p>Most of this flow, except repeated calling of <code>dbBindArrow()</code> or <code>dbBind()</code>,
is implemented by <code>dbGetQueryArrow()</code>,
which should be sufficient
unless you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendQueryArrow()</code> to create a result set object of class
DBIResultArrow.
</p>
</li>
<li>
<p> Optionally, bind query parameters with <code>dbBindArrow()</code> or <code>dbBind()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Use <code>dbFetchArrow()</code> to get a data stream.
</p>
</li>
<li>
<p> Repeat the last two steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>The command execution flow</h3>
<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code>dbBindArrow()</code>,
is implemented by <code>dbExecute()</code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendStatement()</code> to create a result set object of class
DBIResult.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li>
<p> Optionally, bind query parameters with<code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbGetRowsAffected()</code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li>
<p> Repeat the last two steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>Calling <code>dbBind()</code> for a query without parameters
raises an error.
</p>
<p>Binding too many
or not enough values,
or parameters with wrong names
or unequal length,
also raises an error.
If the placeholders in the query are named,
all parameter values must have names
(which must not be empty
or <code>NA</code>),
and vice versa,
otherwise an error is raised.
The behavior for mixing placeholders of different types
(in particular mixing positional and named placeholders)
is not specified.
</p>
<p>Calling <code>dbBind()</code> on a result set already cleared by <code>dbClearResult()</code>
also raises an error.
</p>
<h3>Specification</h3>
<p><span class="pkg">DBI</span> clients execute parametrized statements as follows:
</p>
<ol>
<li>
<p> Call <code>dbSendQuery()</code>, <code>dbSendQueryArrow()</code> or <code>dbSendStatement()</code>
with a query or statement that contains placeholders,
store the returned DBIResult object in a variable.
Mixing placeholders (in particular, named and unnamed ones) is not
recommended.
It is good practice to register a call to <code>dbClearResult()</code> via
<code>on.exit()</code> right after calling <code>dbSendQuery()</code> or <code>dbSendStatement()</code>
(see the last enumeration item).
Until <code>dbBind()</code> or <code>dbBindArrow()</code> have been called,
the returned result set object has the following behavior:
</p>

<ul>
<li> <p><code>dbFetch()</code> raises an error (for <code>dbSendQuery()</code> and <code>dbSendQueryArrow()</code>)
</p>
</li>
<li> <p><code>dbGetRowCount()</code> returns zero (for <code>dbSendQuery()</code> and <code>dbSendQueryArrow()</code>)
</p>
</li>
<li> <p><code>dbGetRowsAffected()</code> returns an integer <code>NA</code> (for <code>dbSendStatement()</code>)
</p>
</li>
<li> <p><code>dbIsValid()</code> returns <code>TRUE</code>
</p>
</li>
<li> <p><code>dbHasCompleted()</code> returns <code>FALSE</code>
</p>
</li>
</ul>
</li>
<li>
<p> Call <code>dbBind()</code> or <code>dbBindArrow()</code>:
</p>

<ul>
<li>
<p> For <code>dbBind()</code>, the <code>params</code> argument must be a list where all elements
have the same lengths and contain values supported by the backend.
A data.frame is internally stored as such a list.
</p>
</li>
<li>
<p> For <code>dbBindArrow()</code>, the <code>params</code> argument must be a
nanoarrow array stream, with one column per query parameter.
</p>
</li>
</ul>
</li>
<li>
<p> Retrieve the data or the number of affected rows from the <code>DBIResult</code> object.
</p>

<ul>
<li>
<p> For queries issued by <code>dbSendQuery()</code> or <code>dbSendQueryArrow()</code>, call <code>dbFetch()</code>.
</p>
</li>
<li>
<p> For statements issued by <code>dbSendStatements()</code>,
call <code>dbGetRowsAffected()</code>.
(Execution begins immediately after the <code>dbBind()</code> call,
the statement is processed entirely before the function returns.)
</p>
</li>
</ul>
</li>
<li>
<p> Repeat 2. and 3. as necessary.
</p>
</li>
<li>
<p> Close the result set via <code>dbClearResult()</code>.
</p>
</li>
</ol>

<p>The elements of the <code>params</code> argument do not need to be scalars,
vectors of arbitrary length
(including length 0)
are supported.
For queries, calling <code>dbFetch()</code> binding such parameters returns
concatenated results, equivalent to binding and fetching for each set
of values and connecting via <code>rbind()</code>.
For data manipulation statements, <code>dbGetRowsAffected()</code> returns the
total number of rows affected if binding non-scalar parameters.
<code>dbBind()</code> also accepts repeated calls on the same result set
for both queries
and data manipulation statements,
even if no results are fetched between calls to <code>dbBind()</code>,
for both queries
and data manipulation statements.
</p>
<p>If the placeholders in the query are named,
their order in the <code>params</code> argument is not important.
</p>
<p>At least the following data types are accepted on input (including NA):
</p>
<ul>
<li> <p>integer
</p>
</li>
<li> <p>numeric
</p>
</li>
<li> <p>logical for Boolean values
</p>
</li>
<li> <p>character
(also with special characters such as spaces, newlines, quotes, and backslashes)
</p>
</li>
<li> <p>factor (bound as character,
with warning)
</p>
</li>
<li> <p>Date
(also when stored internally as integer)
</p>
</li>
<li> <p>POSIXct timestamps
</p>
</li>
<li> <p>POSIXlt timestamps
</p>
</li>
<li> <p>difftime values
(also with units other than seconds
and with the value stored as integer)
</p>
</li>
<li>
<p> lists of raw for blobs (with <code>NULL</code> entries for SQL NULL values)
</p>
</li>
<li>
<p> objects of type blob::blob
</p>
</li>
</ul>

<h3>Examples</h3>
<pre class="r"><code class="language-R">
# Data frame flow:
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "iris", iris)

# Using the same query for different values
iris_result &lt;- dbSendQuery(con, "SELECT * FROM iris WHERE [Petal.Width] &gt; ?")
dbBind(iris_result, list(2.3))
dbFetch(iris_result)
dbBind(iris_result, list(3))
dbFetch(iris_result)
dbClearResult(iris_result)

# Executing the same statement with different values at once
iris_result &lt;- dbSendStatement(con, "DELETE FROM iris WHERE [Species] = \$species")
dbBind(iris_result, list(species = c("setosa", "versicolor", "unknown")))
dbGetRowsAffected(iris_result)
dbClearResult(iris_result)

nrow(dbReadTable(con, "iris"))

dbDisconnect(con)



# Arrow flow:
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "iris", iris)

# Using the same query for different values
iris_result &lt;- dbSendQueryArrow(con, "SELECT * FROM iris WHERE [Petal.Width] &gt; ?")
dbBindArrow(
  iris_result,
  nanoarrow::as_nanoarrow_array_stream(data.frame(2.3, fix.empty.names = FALSE))
)
as.data.frame(dbFetchArrow(iris_result))
dbBindArrow(
  iris_result,
  nanoarrow::as_nanoarrow_array_stream(data.frame(3, fix.empty.names = FALSE))
)
as.data.frame(dbFetchArrow(iris_result))
dbClearResult(iris_result)

# Executing the same statement with different values at once
iris_result &lt;- dbSendStatement(con, "DELETE FROM iris WHERE [Species] = \$species")
dbBindArrow(iris_result, nanoarrow::as_nanoarrow_array_stream(data.frame(
  species = c("setosa", "versicolor", "unknown")
)))
dbGetRowsAffected(iris_result)
dbClearResult(iris_result)

nrow(dbReadTable(con, "iris"))

dbDisconnect(con)

</code></pre>
<h2 id="dbGetQuery">Retrieve results from a query</h2>

<span id="topic+dbGetQuery"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbGetQuery(conn, statement, ...)
</code></pre>
<h3>Description</h3>
<p>Returns the result of a query as a data frame.
<code>dbGetQuery()</code> comes with a default implementation
(which should work with most backends) that calls
<code>dbSendQuery()</code>, then <code>dbFetch()</code>, ensuring that
the result is always freed by <code>dbClearResult()</code>.
For retrieving chunked/paged results or for passing query parameters,
see <code>dbSendQuery()</code>, in particular the "The data retrieval flow" section.
For retrieving results as an Arrow object, see <code>dbGetQueryArrow()</code>.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbGetQuery_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbGetQuery_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td>
</tr>
<tr>
<td><code id="dbGetQuery_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Additional arguments</h3>
<p>The following arguments are not part of the <code>dbGetQuery()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>
<ul>
<li> <p><code>n</code> (default: -1)
</p>
</li>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li>
</ul>

<p>They must be provided as named arguments.
See the "Specification" and "Value" sections for details on their usage.
</p>
<h3>Specification</h3>
<p>A column named <code>row_names</code> is treated like any other column.
</p>
<p>The <code>n</code> argument specifies the number of rows to be fetched.
If omitted, fetching multi-row queries with one
or more columns returns the entire result.
A value of Inf for the <code>n</code> argument is supported
and also returns the full result.
If more rows than available are fetched (by passing a too large value for
<code>n</code>), the result is returned in full without warning.
If zero rows are requested, the columns of the data frame are still fully
typed.
Fetching fewer rows than available is permitted,
no warning is issued.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code>dbBind()</code> for details.
</p>
<h3>Specification for the <code>immediate</code> argument</h3>
<p>The <code>immediate</code> argument supports distinguishing between "direct"
and "prepared" APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the "direct" API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>
<ol>
<li>
<p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed: query is executed
</p>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed:
</p>

<ol>
<li>
<p> simple query: query is executed
</p>
</li>
<li>
<p> "special" query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li>
</ol>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code>dbBind()</code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>

<h3>Details</h3>
<p>This method is for <code>SELECT</code> queries only
(incl. other SQL statements that return a <code>SELECT</code>-alike result,
e.g., execution of a stored procedure or data manipulation queries
like <code style="white-space: pre;">⁠INSERT INTO ... RETURNING ...⁠</code>).
To execute a stored procedure that does not return a result set,
use <code>dbExecute()</code>.
</p>
<p>Some backends may
support data manipulation statements through this method for compatibility
reasons.  However, callers are strongly advised to use
<code>dbExecute()</code> for data manipulation statements.
</p>
<h3>Value</h3>
<p><code>dbGetQuery()</code> always returns a data.frame, with
as many rows as records were fetched and as many
columns as fields in the result set,
even if the result is a single value
or has one
or zero rows.
</p>
<h3>Implementation notes</h3>
<p>Subclasses should override this method only if they provide some sort of
performance optimization.
</p>
<h3>Failure modes</h3>
<p>An error is raised when issuing a query over a closed
or invalid connection,
if the syntax of the query is invalid,
or if the query is not a non-<code>NA</code> string.
If the <code>n</code> argument is not an atomic whole number
greater or equal to -1 or Inf, an error is raised,
but a subsequent call to <code>dbGetQuery()</code> with proper <code>n</code> argument succeeds.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
dbGetQuery(con, "SELECT * FROM mtcars")
dbGetQuery(con, "SELECT * FROM mtcars", n = 6)

# Pass values using the param argument:
# (This query runs eight times, once for each different
# parameter. The resulting rows are combined into a single
# data frame.)
dbGetQuery(
  con,
  "SELECT COUNT(*) FROM mtcars WHERE cyl = ?",
  params = list(1:8)
)

dbDisconnect(con)

</code></pre>
<h2 id="dbSendStatement">Execute a data manipulation statement on a given database connection</h2>

<span id="topic+dbSendStatement"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbSendStatement(conn, statement, ...)
</code></pre>
<h3>Description</h3>
<p>The <code>dbSendStatement()</code> method only submits and synchronously executes the
SQL data manipulation statement (e.g., <code>UPDATE</code>, <code>DELETE</code>,
<code style="white-space: pre;">⁠INSERT INTO⁠</code>, <code style="white-space: pre;">⁠DROP TABLE⁠</code>, ...) to the database engine.  To query
the number of affected rows, call <code>dbGetRowsAffected()</code> on the
returned result object.  You must also call <code>dbClearResult()</code> after
that. For interactive use, you should almost always prefer
<code>dbExecute()</code>.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbSendStatement_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbSendStatement_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td>
</tr>
<tr>
<td><code id="dbSendStatement_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Additional arguments</h3>
<p>The following arguments are not part of the <code>dbSendStatement()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>
<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li>
</ul>

<p>They must be provided as named arguments.
See the "Specification" sections for details on their usage.
</p>
<h3>Specification</h3>
<p>No warnings occur under normal conditions.
When done, the DBIResult object must be cleared with a call to
<code>dbClearResult()</code>.
Failure to clear the result set leads to a warning
when the connection is closed.
If the backend supports only one open result set per connection,
issuing a second query invalidates an already open result set
and raises a warning.
The newly opened result set is valid
and must be cleared with <code>dbClearResult()</code>.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code>dbBind()</code> for details.
</p>
<h3>Specification for the <code>immediate</code> argument</h3>
<p>The <code>immediate</code> argument supports distinguishing between "direct"
and "prepared" APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the "direct" API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>
<ol>
<li>
<p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed: query is executed
</p>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed:
</p>

<ol>
<li>
<p> simple query: query is executed
</p>
</li>
<li>
<p> "special" query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li>
</ol>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code>dbBind()</code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>

<h3>Details</h3>
<p><code>dbSendStatement()</code> comes with a default implementation that simply
forwards to <code>dbSendQuery()</code>, to support backends that only
implement the latter.
</p>
<h3>Value</h3>
<p><code>dbSendStatement()</code> returns
an S4 object that inherits from DBIResult.
The result set can be used with <code>dbGetRowsAffected()</code> to
determine the number of rows affected by the query.
Once you have finished using a result, make sure to clear it
with <code>dbClearResult()</code>.
</p>
<h3>The command execution flow</h3>
<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code>dbBindArrow()</code>,
is implemented by <code>dbExecute()</code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendStatement()</code> to create a result set object of class
DBIResult.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li>
<p> Optionally, bind query parameters with<code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbGetRowsAffected()</code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li>
<p> Repeat the last two steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>An error is raised when issuing a statement over a closed
or invalid connection,
or if the statement is not a non-<code>NA</code> string.
An error is also raised if the syntax of the query is invalid
and all query parameters are given (by passing the <code>params</code> argument)
or the <code>immediate</code> argument is set to <code>TRUE</code>.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cars", head(cars, 3))

rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)"
)
dbHasCompleted(rs)
dbGetRowsAffected(rs)
dbClearResult(rs)
dbReadTable(con, "cars")   # there are now 6 rows

# Pass one set of values directly using the param argument:
rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)",
  params = list(4L, 5L)
)
dbClearResult(rs)

# Pass multiple sets of values using dbBind():
rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)"
)
dbBind(rs, list(5:6, 6:7))
dbBind(rs, list(7L, 8L))
dbClearResult(rs)
dbReadTable(con, "cars")   # there are now 10 rows

dbDisconnect(con)

</code></pre>
<h2 id="dbExecute">Change database state</h2>

<span id="topic+dbExecute"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbExecute(conn, statement, ...)
</code></pre>
<h3>Description</h3>
<p>Executes a statement and returns the number of rows affected.
<code>dbExecute()</code> comes with a default implementation
(which should work with most backends) that calls
<code>dbSendStatement()</code>, then <code>dbGetRowsAffected()</code>, ensuring that
the result is always freed by <code>dbClearResult()</code>.
For passing query parameters, see <code>dbBind()</code>, in particular
the "The command execution flow" section.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbExecute_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbExecute_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td>
</tr>
<tr>
<td><code id="dbExecute_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Additional arguments</h3>
<p>The following arguments are not part of the <code>dbExecute()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>
<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li>
</ul>

<p>They must be provided as named arguments.
See the "Specification" sections for details on their usage.
</p>
<h3>Specification</h3>
<p>The <code>param</code> argument allows passing query parameters, see <code>dbBind()</code> for details.
</p>
<h3>Specification for the <code>immediate</code> argument</h3>
<p>The <code>immediate</code> argument supports distinguishing between "direct"
and "prepared" APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the "direct" API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>
<ol>
<li>
<p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed: query is executed
</p>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li>
<p> A query without parameters is passed:
</p>

<ol>
<li>
<p> simple query: query is executed
</p>
</li>
<li>
<p> "special" query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li>
</ol>
</li>
<li>
<p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code>dbBind()</code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>

<h3>Details</h3>
<p>You can also use <code>dbExecute()</code> to call a stored procedure
that performs data manipulation or other actions that do not return a result set.
To execute a stored procedure that returns a result set,
or a data manipulation query that also returns a result set
such as <code style="white-space: pre;">⁠INSERT INTO ... RETURNING ...⁠</code>, use <code>dbGetQuery()</code> instead.
</p>
<h3>Value</h3>
<p><code>dbExecute()</code> always returns a
scalar
numeric
that specifies the number of rows affected
by the statement.
</p>
<h3>Implementation notes</h3>
<p>Subclasses should override this method only if they provide some sort of
performance optimization.
</p>
<h3>Failure modes</h3>
<p>An error is raised when issuing a statement over a closed
or invalid connection,
if the syntax of the statement is invalid,
or if the statement is not a non-<code>NA</code> string.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cars", head(cars, 3))
dbReadTable(con, "cars")   # there are 3 rows
dbExecute(
  con,
  "INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)"
)
dbReadTable(con, "cars")   # there are now 6 rows

# Pass values using the param argument:
dbExecute(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)",
  params = list(4:7, 5:8)
)
dbReadTable(con, "cars")   # there are now 10 rows

dbDisconnect(con)

</code></pre>
<h2 id="dbQuoteString">Quote literal strings</h2>

<span id="topic+dbQuoteString"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbQuoteString(conn, x, ...)
</code></pre>
<h3>Description</h3>
<p>Call this method to generate a string that is suitable for
use in a query as a string literal, to make sure that you
generate valid SQL and protect against SQL injection attacks.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbQuoteString_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbQuoteString_+3A_x">x</code></td>
<td>
<p>A character vector to quote as string.</p>
</td>
</tr>
<tr>
<td><code id="dbQuoteString_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbQuoteString()</code> returns an object that can be coerced to character,
of the same length as the input.
For an empty character vector this function returns a length-0 object.
</p>
<p>When passing the returned object again to <code>dbQuoteString()</code>
as <code>x</code>
argument, it is returned unchanged.
Passing objects of class SQL should also return them unchanged.
(For backends it may be most convenient to return SQL objects
to achieve this behavior, but this is not required.)
</p>
<h3>Failure modes</h3>
<p>Passing a numeric,
integer,
logical,
or raw vector,
or a list
for the <code>x</code> argument raises an error.
</p>
<h3>Specification</h3>
<p>The returned expression can be used in a <code style="white-space: pre;">⁠SELECT ...⁠</code> query,
and for any scalar character <code>x</code> the value of
<code>dbGetQuery(paste0("SELECT ", dbQuoteString(x)))[[1]]</code>
must be identical to <code>x</code>,
even if <code>x</code> contains
spaces,
tabs,
quotes (single
or double),
backticks,
or newlines
(in any combination)
or is itself the result of a <code>dbQuoteString()</code> call coerced back to
character (even repeatedly).
If <code>x</code> is <code>NA</code>, the result must merely satisfy <code>is.na()</code>.
The strings <code>"NA"</code> or <code>"NULL"</code> are not treated specially.
</p>
<p><code>NA</code> should be translated to an unquoted SQL <code>NULL</code>,
so that the query <code style="white-space: pre;">⁠SELECT * FROM (SELECT 1) a WHERE ... IS NULL⁠</code>
returns one row.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R"># Quoting ensures that arbitrary input is safe for use in a query
name &lt;- "Robert'); DROP TABLE Students;--"
dbQuoteString(ANSI(), name)

# NAs become NULL
dbQuoteString(ANSI(), c("x", NA))

# SQL vectors are always passed through as is
var_name &lt;- SQL("select")
var_name
dbQuoteString(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteString(ANSI(), dbQuoteString(ANSI(), name))
</code></pre>
<h2 id="dbQuoteIdentifier">Quote identifiers</h2>

<span id="topic+dbQuoteIdentifier"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbQuoteIdentifier(conn, x, ...)
</code></pre>
<h3>Description</h3>
<p>Call this method to generate a string that is suitable for
use in a query as a column or table name, to make sure that you
generate valid SQL and protect against SQL injection attacks. The inverse
operation is <code>dbUnquoteIdentifier()</code>.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbQuoteIdentifier_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbQuoteIdentifier_+3A_x">x</code></td>
<td>
<p>A character vector, SQL or Id object to quote as identifier.</p>
</td>
</tr>
<tr>
<td><code id="dbQuoteIdentifier_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbQuoteIdentifier()</code> returns an object that can be coerced to character,
of the same length as the input.
For an empty character vector this function returns a length-0 object.
The names of the input argument are preserved in the output.
When passing the returned object again to <code>dbQuoteIdentifier()</code>
as <code>x</code>
argument, it is returned unchanged.
Passing objects of class SQL should also return them unchanged.
(For backends it may be most convenient to return SQL objects
to achieve this behavior, but this is not required.)
</p>
<h3>Failure modes</h3>
<p>An error is raised if the input contains <code>NA</code>,
but not for an empty string.
</p>
<h3>Specification</h3>
<p>Calling <code>dbGetQuery()</code> for a query of the format <code style="white-space: pre;">⁠SELECT 1 AS ...⁠</code>
returns a data frame with the identifier, unquoted, as column name.
Quoted identifiers can be used as table and column names in SQL queries,
in particular in queries like <code style="white-space: pre;">⁠SELECT 1 AS ...⁠</code>
and <code style="white-space: pre;">⁠SELECT * FROM (SELECT 1) ...⁠</code>.
The method must use a quoting mechanism that is unambiguously different
from the quoting mechanism used for strings, so that a query like
<code style="white-space: pre;">⁠SELECT ... FROM (SELECT 1 AS ...)⁠</code>
throws an error if the column names do not match.
</p>
<p>The method can quote column names that
contain special characters such as a space,
a dot,
a comma,
or quotes used to mark strings
or identifiers,
if the database supports this.
In any case, checking the validity of the identifier
should be performed only when executing a query,
and not by <code>dbQuoteIdentifier()</code>.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R"># Quoting ensures that arbitrary input is safe for use in a query
name &lt;- "Robert'); DROP TABLE Students;--"
dbQuoteIdentifier(ANSI(), name)

# Use Id() to specify other components such as the schema
id_name &lt;- Id(schema = "schema_name", table = "table_name")
id_name
dbQuoteIdentifier(ANSI(), id_name)

# SQL vectors are always passed through as is
var_name &lt;- SQL("select")
var_name
dbQuoteIdentifier(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteIdentifier(ANSI(), dbQuoteIdentifier(ANSI(), name))
</code></pre>
<h2 id="dbReadTable">Read database tables as data frames</h2>

<span id="topic+dbReadTable"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbReadTable(conn, name, ...)
</code></pre>
<h3>Description</h3>
<p>Reads a database table to a data frame, optionally converting
a column to row names and converting the column names to valid
R identifiers.
Use <code>dbReadTableArrow()</code> instead to obtain an Arrow object.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbReadTable_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbReadTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code>dbQuoteIdentifier()</code>. Options are:
</p>

<ul>
<li>
<p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li>
<p> a call to <code>Id()</code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li>
<p> a call to <code>SQL()</code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li>
</ul>
</td>
</tr>
<tr>
<td><code id="dbReadTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Additional arguments</h3>
<p>The following arguments are not part of the <code>dbReadTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>
<ul>
<li> <p><code>row.names</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>check.names</code>
</p>
</li>
</ul>

<p>They must be provided as named arguments.
See the "Value" section for details on their usage.
</p>
<h3>Specification</h3>
<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>
<ul>
<li>
<p> If an unquoted table name as string: <code>dbReadTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li>
<p> If the result of a call to <code>dbQuoteIdentifier()</code>: no more quoting is done
</p>
</li>
</ul>

<h3>Details</h3>
<p>This function returns a data frame.
Use <code>dbReadTableArrow()</code> to obtain an Arrow object.
</p>
<h3>Value</h3>
<p><code>dbReadTable()</code> returns a data frame that contains the complete data
from the remote table, effectively the result of calling <code>dbGetQuery()</code> with
<code style="white-space: pre;">⁠SELECT * FROM &lt;name&gt;⁠</code>.
</p>
<p>An empty table is returned as a data frame with zero rows.
</p>
<p>The presence of rownames depends on the <code>row.names</code> argument,
see <code>sqlColumnToRownames()</code> for details:
</p>
<ul>
<li>
<p> If <code>FALSE</code> or <code>NULL</code>, the returned data frame doesn't have row names.
</p>
</li>
<li>
<p> If <code>TRUE</code>, a column named "row_names" is converted to row names.
</p>
</li>
</ul>

<ul>
<li>
<p> If <code>NA</code>, a column named "row_names" is converted to row names if it exists,
otherwise no translation occurs.
</p>
</li>
<li>
<p> If a string, this specifies the name of the column in the remote table
that contains the row names.
</p>
</li>
</ul>

<p>The default is <code>row.names = FALSE</code>.
</p>
<p>If the database supports identifiers with special characters,
the columns in the returned data frame are converted to valid R
identifiers
if the <code>check.names</code> argument is <code>TRUE</code>,
If <code>check.names = FALSE</code>, the returned table has non-syntactic column names without quotes.
</p>
<h3>Failure modes</h3>
<p>An error is raised if the table does not exist.
</p>
<p>An error is raised if <code>row.names</code> is <code>TRUE</code> and no "row_names" column exists,
</p>
<p>An error is raised if <code>row.names</code> is set to a string and no corresponding column exists.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is raised
if <code>name</code> cannot be processed with <code>dbQuoteIdentifier()</code>
or if this results in a non-scalar.
Unsupported values for <code>row.names</code> and <code>check.names</code>
(non-scalars,
unsupported data types,
<code>NA</code> for <code>check.names</code>)
also raise an error.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:10, ])
dbReadTable(con, "mtcars")

dbDisconnect(con)

</code></pre>
<h2 id="dbWriteTable">Copy data frames to database tables</h2>

<span id="topic+dbWriteTable"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbWriteTable(conn, name, value, ...)
</code></pre>
<h3>Description</h3>
<p>Writes, overwrites or appends a data frame to a database table, optionally
converting row names to a column and specifying SQL data types for fields.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbWriteTable_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbWriteTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code>dbQuoteIdentifier()</code>. Options are:
</p>

<ul>
<li>
<p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li>
<p> a call to <code>Id()</code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li>
<p> a call to <code>SQL()</code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li>
</ul>
</td>
</tr>
<tr>
<td><code id="dbWriteTable_+3A_value">value</code></td>
<td>
<p>A data.frame (or coercible to data.frame).</p>
</td>
</tr>
<tr>
<td><code id="dbWriteTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Additional arguments</h3>
<p>The following arguments are not part of the <code>dbWriteTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>
<ul>
<li> <p><code>row.names</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>overwrite</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>append</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>field.types</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>temporary</code> (default: <code>FALSE</code>)
</p>
</li>
</ul>

<p>They must be provided as named arguments.
See the "Specification" and "Value" sections for details on their usage.
</p>
<h3>Specification</h3>
<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>
<ul>
<li>
<p> If an unquoted table name as string: <code>dbWriteTable()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li>
<p> If the result of a call to <code>dbQuoteIdentifier()</code>: no more quoting is done
</p>
</li>
</ul>

<p>The <code>value</code> argument must be a data frame
with a subset of the columns of the existing table if <code>append = TRUE</code>.
The order of the columns does not matter with <code>append = TRUE</code>.
</p>
<p>If the <code>overwrite</code> argument is <code>TRUE</code>, an existing table of the same name
will be overwritten.
This argument doesn't change behavior if the table does not exist yet.
</p>
<p>If the <code>append</code> argument is <code>TRUE</code>, the rows in an existing table are
preserved, and the new data are appended.
If the table doesn't exist yet, it is created.
</p>
<p>If the <code>temporary</code> argument is <code>TRUE</code>, the table is not available in a
second connection and is gone after reconnecting.
Not all backends support this argument.
A regular, non-temporary table is visible in a second connection,
in a pre-existing connection,
and after reconnecting to the database.
</p>
<p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, spaces, and other special characters such as newlines and tabs,
can also be used in the data,
and, if the database supports non-syntactic identifiers,
also for table names
and column names.
</p>
<p>The following data types must be supported at least,
and be read identically with <code>dbReadTable()</code>:
</p>
<ul>
<li>
<p> integer
</p>
</li>
<li>
<p> numeric
(the behavior for <code>Inf</code> and <code>NaN</code> is not specified)
</p>
</li>
<li>
<p> logical
</p>
</li>
<li> <p><code>NA</code> as NULL
</p>
</li>
<li>
<p> 64-bit values (using <code>"bigint"</code> as field type); the result can be
</p>

<ul>
<li>
<p> converted to a numeric, which may lose precision,
</p>
</li>
<li>
<p> converted a character vector, which gives the full decimal
representation
</p>
</li>
<li>
<p> written to another table and read again unchanged
</p>
</li>
</ul>
</li>
<li>
<p> character (in both UTF-8
and native encodings),
supporting empty strings
before and after a non-empty string
</p>
</li>
<li>
<p> factor (returned as character)
</p>
</li>
<li>
<p> list of raw
(if supported by the database)
</p>
</li>
<li>
<p> objects of type blob::blob
(if supported by the database)
</p>
</li>
<li>
<p> date
(if supported by the database;
returned as <code>Date</code>),
also for dates prior to 1970 or 1900 or after 2038
</p>
</li>
<li>
<p> time
(if supported by the database;
returned as objects that inherit from <code>difftime</code>)
</p>
</li>
<li>
<p> timestamp
(if supported by the database;
returned as <code>POSIXct</code>
respecting the time zone but not necessarily preserving the
input time zone),
also for timestamps prior to 1970 or 1900 or after 2038
respecting the time zone but not necessarily preserving the
input time zone)
</p>
</li>
</ul>

<p>Mixing column types in the same table is supported.
</p>
<p>The <code>field.types</code> argument must be a named character vector with at most
one entry for each column.
It indicates the SQL data type to be used for a new column.
If a column is missed from <code>field.types</code>, the type is inferred
from the input data with <code>dbDataType()</code>.
</p>
<p>The interpretation of rownames depends on the <code>row.names</code> argument,
see <code>sqlRownamesToColumn()</code> for details:
</p>
<ul>
<li>
<p> If <code>FALSE</code> or <code>NULL</code>, row names are ignored.
</p>
</li>
<li>
<p> If <code>TRUE</code>, row names are converted to a column named "row_names",
even if the input data frame only has natural row names from 1 to <code>nrow(...)</code>.
</p>
</li>
<li>
<p> If <code>NA</code>, a column named "row_names" is created if the data has custom row names,
no extra column is created in the case of natural row names.
</p>
</li>
<li>
<p> If a string, this specifies the name of the column in the remote table
that contains the row names,
even if the input data frame only has natural row names.
</p>
</li>
</ul>

<p>The default is <code>row.names = FALSE</code>.
</p>
<h3>Details</h3>
<p>This function expects a data frame.
Use <code>dbWriteTableArrow()</code> to write an Arrow object.
</p>
<p>This function is useful if you want to create and load a table at the same time.
Use <code>dbAppendTable()</code> or <code>dbAppendTableArrow()</code> for appending data to an existing
table, <code>dbCreateTable()</code> or <code>dbCreateTableArrow()</code> for creating a table,
and <code>dbExistsTable()</code> and <code>dbRemoveTable()</code> for overwriting tables.
</p>
<p>DBI only standardizes writing data frames with <code>dbWriteTable()</code>.
Some backends might implement methods that can consume CSV files
or other data formats.
For details, see the documentation for the individual methods.
</p>
<h3>Value</h3>
<p><code>dbWriteTable()</code> returns <code>TRUE</code>, invisibly.
</p>
<h3>Failure modes</h3>
<p>If the table exists, and both <code>append</code> and <code>overwrite</code> arguments are unset,
or <code>append = TRUE</code> and the data frame with the new data has different
column names,
an error is raised; the remote table remains unchanged.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code>dbQuoteIdentifier()</code> or
if this results in a non-scalar.
Invalid values for the additional arguments <code>row.names</code>,
<code>overwrite</code>, <code>append</code>, <code>field.types</code>, and <code>temporary</code>
(non-scalars,
unsupported data types,
<code>NA</code>,
incompatible values,
duplicate
or missing names,
incompatible columns)
also raise an error.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:5, ])
dbReadTable(con, "mtcars")

dbWriteTable(con, "mtcars", mtcars[6:10, ], append = TRUE)
dbReadTable(con, "mtcars")

dbWriteTable(con, "mtcars", mtcars[1:10, ], overwrite = TRUE)
dbReadTable(con, "mtcars")

# No row names
dbWriteTable(con, "mtcars", mtcars[1:10, ], overwrite = TRUE, row.names = FALSE)
dbReadTable(con, "mtcars")

</code></pre>
<h2 id="dbListTables">List remote tables</h2>

<span id="topic+dbListTables"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbListTables(conn, ...)
</code></pre>
<h3>Description</h3>
<p>Returns the unquoted names of remote tables accessible through this
connection.
This should include views and temporary objects, but not all database backends
(in particular <span class="pkg">RMariaDB</span> and <span class="pkg">RMySQL</span>) support this.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbListTables_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbListTables_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbListTables()</code>
returns a character vector
that enumerates all tables
and views
in the database.
Tables added with <code>dbWriteTable()</code> are
part of the list.
As soon a table is removed from the database,
it is also removed from the list of database tables.
</p>
<p>The same applies to temporary tables if supported by the database.
</p>
<p>The returned names are suitable for quoting with <code>dbQuoteIdentifier()</code>.
</p>
<h3>Failure modes</h3>
<p>An error is raised when calling this method for a closed
or invalid connection.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbListTables(con)
dbWriteTable(con, "mtcars", mtcars)
dbListTables(con)

dbDisconnect(con)

</code></pre>
<h2 id="dbExistsTable">Does a table exist?</h2>

<span id="topic+dbExistsTable"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbExistsTable(conn, name, ...)
</code></pre>
<h3>Description</h3>
<p>Returns if a table given by name exists in the database.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbExistsTable_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbExistsTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code>dbQuoteIdentifier()</code>. Options are:
</p>

<ul>
<li>
<p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li>
<p> a call to <code>Id()</code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li>
<p> a call to <code>SQL()</code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li>
</ul>
</td>
</tr>
<tr>
<td><code id="dbExistsTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbExistsTable()</code> returns a logical scalar, <code>TRUE</code> if the table or view
specified by the <code>name</code> argument exists, <code>FALSE</code> otherwise.
</p>
<p>This includes temporary tables if supported by the database.
</p>
<h3>Failure modes</h3>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code>dbQuoteIdentifier()</code> or
if this results in a non-scalar.
</p>
<h3>Specification</h3>
<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>
<ul>
<li>
<p> If an unquoted table name as string: <code>dbExistsTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li>
<p> If the result of a call to <code>dbQuoteIdentifier()</code>: no more quoting is done
</p>
</li>
</ul>

<p>For all tables listed by <code>dbListTables()</code>, <code>dbExistsTable()</code> returns <code>TRUE</code>.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbExistsTable(con, "iris")
dbWriteTable(con, "iris", iris)
dbExistsTable(con, "iris")

dbDisconnect(con)

</code></pre>
<h2 id="dbRemoveTable">Remove a table from the database</h2>

<span id="topic+dbRemoveTable"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbRemoveTable(conn, name, ...)
</code></pre>
<h3>Description</h3>
<p>Remove a remote table (e.g., created by <code>dbWriteTable()</code>)
from the database.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbRemoveTable_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbRemoveTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code>dbQuoteIdentifier()</code>. Options are:
</p>

<ul>
<li>
<p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li>
<p> a call to <code>Id()</code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li>
<p> a call to <code>SQL()</code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li>
</ul>
</td>
</tr>
<tr>
<td><code id="dbRemoveTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Additional arguments</h3>
<p>The following arguments are not part of the <code>dbRemoveTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>
<ul>
<li> <p><code>temporary</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>fail_if_missing</code> (default: <code>TRUE</code>)
</p>
</li>
</ul>

<p>These arguments must be provided as named arguments.
</p>
<p>If <code>temporary</code> is <code>TRUE</code>, the call to <code>dbRemoveTable()</code>
will consider only temporary tables.
Not all backends support this argument.
In particular, permanent tables of the same name are left untouched.
</p>
<p>If <code>fail_if_missing</code> is <code>FALSE</code>, the call to <code>dbRemoveTable()</code>
succeeds if the table does not exist.
</p>
<h3>Specification</h3>
<p>A table removed by <code>dbRemoveTable()</code> doesn't appear in the list of tables
returned by <code>dbListTables()</code>,
and <code>dbExistsTable()</code> returns <code>FALSE</code>.
The removal propagates immediately to other connections to the same database.
This function can also be used to remove a temporary table.
</p>
<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>
<ul>
<li>
<p> If an unquoted table name as string: <code>dbRemoveTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li>
<p> If the result of a call to <code>dbQuoteIdentifier()</code>: no more quoting is done
</p>
</li>
</ul>

<h3>Value</h3>
<p><code>dbRemoveTable()</code> returns <code>TRUE</code>, invisibly.
</p>
<h3>Failure modes</h3>
<p>If the table does not exist, an error is raised.
An attempt to remove a view with this function may result in an error.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code>dbQuoteIdentifier()</code> or
if this results in a non-scalar.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbExistsTable(con, "iris")
dbWriteTable(con, "iris", iris)
dbExistsTable(con, "iris")
dbRemoveTable(con, "iris")
dbExistsTable(con, "iris")

dbDisconnect(con)

</code></pre>
<h2 id="dbListFields">List field names of a remote table</h2>

<span id="topic+dbListFields"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbListFields(conn, name, ...)
</code></pre>
<h3>Description</h3>
<p>Returns the field names of a remote table as a character vector.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbListFields_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbListFields_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code>dbQuoteIdentifier()</code>. Options are:
</p>

<ul>
<li>
<p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li>
<p> a call to <code>Id()</code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li>
<p> a call to <code>SQL()</code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li>
</ul>
</td>
</tr>
<tr>
<td><code id="dbListFields_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbListFields()</code>
returns a character vector
that enumerates all fields
in the table in the correct order.
This also works for temporary tables if supported by the database.
The returned names are suitable for quoting with <code>dbQuoteIdentifier()</code>.
</p>
<h3>Failure modes</h3>
<p>If the table does not exist, an error is raised.
Invalid types for the <code>name</code> argument
(e.g., <code>character</code> of length not equal to one,
or numeric)
lead to an error.
An error is also raised when calling this method for a closed
or invalid connection.
</p>
<h3>Specification</h3>
<p>The <code>name</code> argument can be
</p>
<ul>
<li>
<p> a string
</p>
</li>
<li>
<p> the return value of <code>dbQuoteIdentifier()</code>
</p>
</li>
<li>
<p> a value from the <code>table</code> column from the return value of
<code>dbListObjects()</code> where <code>is_prefix</code> is <code>FALSE</code>
</p>
</li>
</ul>

<p>A column named <code>row_names</code> is treated like any other column.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
dbListFields(con, "mtcars")

dbDisconnect(con)

</code></pre>
<h2 id="dbIsValid">Is this DBMS object still valid?</h2>

<span id="topic+dbIsValid"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbIsValid(dbObj, ...)
</code></pre>
<h3>Description</h3>
<p>This generic tests whether a database object is still valid (i.e. it hasn't
been disconnected or cleared).
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbIsValid_+3A_dbobj">dbObj</code></td>
<td>
<p>An object inheriting from DBIObject,
i.e. DBIDriver, DBIConnection,
or a DBIResult</p>
</td>
</tr>
<tr>
<td><code id="dbIsValid_+3A_...">...</code></td>
<td>
<p>Other arguments to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbIsValid()</code> returns a logical scalar,
<code>TRUE</code> if the object specified by <code>dbObj</code> is valid,
<code>FALSE</code> otherwise.
A DBIConnection object is initially valid,
and becomes invalid after disconnecting with <code>dbDisconnect()</code>.
For an invalid connection object (e.g., for some drivers if the object
is saved to a file and then restored), the method also returns <code>FALSE</code>.
A DBIResult object is valid after a call to <code>dbSendQuery()</code>,
and stays valid even after all rows have been fetched;
only clearing it with <code>dbClearResult()</code> invalidates it.
A DBIResult object is also valid after a call to <code>dbSendStatement()</code>,
and stays valid after querying the number of rows affected;
only clearing it with <code>dbClearResult()</code> invalidates it.
If the connection to the database system is dropped (e.g., due to
connectivity problems, server failure, etc.), <code>dbIsValid()</code> should return
<code>FALSE</code>. This is not tested automatically.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
dbIsValid(RSQLite::SQLite())

con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbIsValid(con)

rs &lt;- dbSendQuery(con, "SELECT 1")
dbIsValid(rs)

dbClearResult(rs)
dbIsValid(rs)

dbDisconnect(con)
dbIsValid(con)

</code></pre>
<h2 id="dbHasCompleted">Completion status</h2>

<span id="topic+dbHasCompleted"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbHasCompleted(res, ...)
</code></pre>
<h3>Description</h3>
<p>This method returns if the operation has completed.
A <code>SELECT</code> query is completed if all rows have been fetched.
A data manipulation statement is always completed.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbHasCompleted_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult.</p>
</td>
</tr>
<tr>
<td><code id="dbHasCompleted_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbHasCompleted()</code> returns a logical scalar.
For a query initiated by <code>dbSendQuery()</code> with non-empty result set,
<code>dbHasCompleted()</code> returns <code>FALSE</code> initially
and <code>TRUE</code> after calling <code>dbFetch()</code> without limit.
For a query initiated by <code>dbSendStatement()</code>,
<code>dbHasCompleted()</code> always returns <code>TRUE</code>.
</p>
<h3>The data retrieval flow</h3>
<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code>dbBind()</code> or <code>dbBindArrow()</code>,
is implemented by <code>dbGetQuery()</code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendQuery()</code> to create a result set object of class
DBIResult.
</p>
</li>
<li>
<p> Optionally, bind query parameters with <code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbColumnInfo()</code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li>
<p> Use <code>dbFetch()</code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li>
<p> Use <code>dbHasCompleted()</code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li>
<p> Repeat the last four steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>Attempting to query completion status for a result set cleared with
<code>dbClearResult()</code> gives an error.
</p>
<h3>Specification</h3>
<p>The completion status for a query is only guaranteed to be set to
<code>FALSE</code> after attempting to fetch past the end of the entire result.
Therefore, for a query with an empty result set,
the initial return value is unspecified,
but the result value is <code>TRUE</code> after trying to fetch only one row.
</p>
<p>Similarly, for a query with a result set of length n,
the return value is unspecified after fetching n rows,
but the result value is <code>TRUE</code> after trying to fetch only one more
row.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")

dbHasCompleted(rs)
ret1 &lt;- dbFetch(rs, 10)
dbHasCompleted(rs)
ret2 &lt;- dbFetch(rs)
dbHasCompleted(rs)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>
<h2 id="dbGetStatement">Get the statement associated with a result set</h2>

<span id="topic+dbGetStatement"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbGetStatement(res, ...)
</code></pre>
<h3>Description</h3>
<p>Returns the statement that was passed to <code>dbSendQuery()</code>
or <code>dbSendStatement()</code>.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbGetStatement_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult.</p>
</td>
</tr>
<tr>
<td><code id="dbGetStatement_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbGetStatement()</code> returns a string, the query used in
either <code>dbSendQuery()</code> or
<code>dbSendStatement()</code>.
</p>
<h3>Failure modes</h3>
<p>Attempting to query the statement for a result set cleared with
<code>dbClearResult()</code> gives an error.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")
dbGetStatement(rs)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>
<h2 id="dbGetRowCount">The number of rows fetched so far</h2>

<span id="topic+dbGetRowCount"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbGetRowCount(res, ...)
</code></pre>
<h3>Description</h3>
<p>Returns the total number of rows actually fetched with calls to <code>dbFetch()</code>
for this result set.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbGetRowCount_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult.</p>
</td>
</tr>
<tr>
<td><code id="dbGetRowCount_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbGetRowCount()</code> returns a scalar number (integer or numeric),
the number of rows fetched so far.
After calling <code>dbSendQuery()</code>,
the row count is initially zero.
After a call to <code>dbFetch()</code> without limit,
the row count matches the total number of rows returned.
Fetching a limited number of rows
increases the number of rows by the number of rows returned,
even if fetching past the end of the result set.
For queries with an empty result set,
zero is returned
even after fetching.
For data manipulation statements issued with
<code>dbSendStatement()</code>,
zero is returned before
and after calling <code>dbFetch()</code>.
</p>
<h3>Failure modes</h3>
<p>Attempting to get the row count for a result set cleared with
<code>dbClearResult()</code> gives an error.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")

dbGetRowCount(rs)
ret1 &lt;- dbFetch(rs, 10)
dbGetRowCount(rs)
ret2 &lt;- dbFetch(rs)
dbGetRowCount(rs)
nrow(ret1) + nrow(ret2)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>
<h2 id="dbGetRowsAffected">The number of rows affected</h2>

<span id="topic+dbGetRowsAffected"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbGetRowsAffected(res, ...)
</code></pre>
<h3>Description</h3>
<p>This method returns the number of rows that were added, deleted, or updated
by a data manipulation statement.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbGetRowsAffected_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult.</p>
</td>
</tr>
<tr>
<td><code id="dbGetRowsAffected_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbGetRowsAffected()</code> returns a scalar number (integer or numeric),
the number of rows affected by a data manipulation statement
issued with <code>dbSendStatement()</code>.
The value is available directly after the call
and does not change after calling <code>dbFetch()</code>.
<code>NA_integer_</code> or <code>NA_numeric_</code> are allowed if the number of rows affected is not known.
</p>
<p>For queries issued with <code>dbSendQuery()</code>,
zero is returned before
and after the call to <code>dbFetch()</code>.
<code>NA</code> values are not allowed.
</p>
<h3>The command execution flow</h3>
<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code>dbBindArrow()</code>,
is implemented by <code>dbExecute()</code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendStatement()</code> to create a result set object of class
DBIResult.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li>
<p> Optionally, bind query parameters with<code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbGetRowsAffected()</code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li>
<p> Repeat the last two steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>Attempting to get the rows affected for a result set cleared with
<code>dbClearResult()</code> gives an error.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendStatement(con, "DELETE FROM mtcars")
dbGetRowsAffected(rs)
nrow(mtcars)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>
<h2 id="dbColumnInfo">Information about result types</h2>

<span id="topic+dbColumnInfo"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbColumnInfo(res, ...)
</code></pre>
<h3>Description</h3>
<p>Produces a data.frame that describes the output of a query. The data.frame
should have as many rows as there are output fields in the result set, and
each column in the data.frame describes an aspect of the result set
field (field name, type, etc.)
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbColumnInfo_+3A_res">res</code></td>
<td>
<p>An object inheriting from DBIResult.</p>
</td>
</tr>
<tr>
<td><code id="dbColumnInfo_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p><code>dbColumnInfo()</code>
returns a data frame
with at least two columns <code>"name"</code> and <code>"type"</code> (in that order)
(and optional columns that start with a dot).
The <code>"name"</code> and <code>"type"</code> columns contain the names and types
of the R columns of the data frame that is returned from <code>dbFetch()</code>.
The <code>"type"</code> column is of type <code>character</code> and only for information.
Do not compute on the <code>"type"</code> column, instead use <code>dbFetch(res, n = 0)</code>
to create a zero-row data frame initialized with the correct data types.
</p>
<h3>The data retrieval flow</h3>
<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code>dbBind()</code> or <code>dbBindArrow()</code>,
is implemented by <code>dbGetQuery()</code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code>dbConnect()</code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>
<ol>
<li>
<p> Use <code>dbSendQuery()</code> to create a result set object of class
DBIResult.
</p>
</li>
<li>
<p> Optionally, bind query parameters with <code>dbBind()</code> or <code>dbBindArrow()</code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">⁠?⁠</code> or <code style="white-space: pre;">⁠\$1⁠</code>, depending on the database backend.
</p>
</li>
<li>
<p> Optionally, use <code>dbColumnInfo()</code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li>
<p> Use <code>dbFetch()</code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li>
<p> Use <code>dbHasCompleted()</code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li>
<p> Repeat the last four steps as necessary.
</p>
</li>
<li>
<p> Use <code>dbClearResult()</code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code>on.exit()</code> or <code>withr::defer()</code>
to ensure that this step is always executed.
</p>
</li>
</ol>

<h3>Failure modes</h3>
<p>An attempt to query columns for a closed result set raises an error.
</p>
<h3>Specification</h3>
<p>A column named <code>row_names</code> is treated like any other column.
</p>
<p>The column names are always consistent
with the data returned by <code>dbFetch()</code>.
</p>
<p>If the query returns unnamed columns,
non-empty and non-<code>NA</code> names are assigned.
</p>
<p>Column names that correspond to SQL or R keywords are left unchanged.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

rs &lt;- dbSendQuery(con, "SELECT 1 AS a, 2 AS b")
dbColumnInfo(rs)
dbFetch(rs)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>
<h2 id="dbBegin">Begin/commit/rollback SQL transactions</h2>

<span id="topic+dbBegin"></span>
<span id="topic+dbCommit"></span>
<span id="topic+dbRollback"></span>
<span id="topic+transactions"></span>
<p>This section describes the behavior of the following methods:</p>
<pre class="r"><code class="language-R">dbBegin(conn, ...)

dbCommit(conn, ...)

dbRollback(conn, ...)
</code></pre>
<h3>Description</h3>
<p>A transaction encapsulates several SQL statements in an atomic unit.
It is initiated with <code>dbBegin()</code> and either made persistent with <code>dbCommit()</code>
or undone with <code>dbRollback()</code>.
In any case, the DBMS guarantees that either all or none of the statements
have a permanent effect.
This helps ensuring consistency of write operations to multiple tables.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbBegin_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbBegin_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Details</h3>
<p>Not all database engines implement transaction management, in which case
these methods should not be implemented for the specific
DBIConnection subclass.
</p>
<h3>Value</h3>
<p><code>dbBegin()</code>, <code>dbCommit()</code> and <code>dbRollback()</code> return <code>TRUE</code>, invisibly.
</p>
<h3>Failure modes</h3>
<p>The implementations are expected to raise an error in case of failure,
but this is not tested.
In any way, all generics throw an error with a closed
or invalid connection.
In addition, a call to <code>dbCommit()</code>
or <code>dbRollback()</code>
without a prior call to <code>dbBegin()</code> raises an error.
Nested transactions are not supported by DBI,
an attempt to call <code>dbBegin()</code> twice
yields an error.
</p>
<h3>Specification</h3>
<p>Actual support for transactions may vary between backends.
A transaction is initiated by a call to <code>dbBegin()</code>
and committed by a call to <code>dbCommit()</code>.
Data written in a transaction must persist after the transaction is committed.
For example, a record that is missing when the transaction is started
but is created during the transaction
must exist
both during
and after the transaction,
and also in a new connection.
</p>
<p>A transaction
can also be aborted with <code>dbRollback()</code>.
All data written in such a transaction must be removed after the
transaction is rolled back.
For example, a record that is missing when the transaction is started
but is created during the transaction
must not exist anymore after the rollback.
</p>
<p>Disconnection from a connection with an open transaction
effectively rolls back the transaction.
All data written in such a transaction must be removed after the
transaction is rolled back.
</p>
<p>The behavior is not specified if other arguments are passed to these
functions. In particular, <span class="pkg">RSQLite</span> issues named transactions
with support for nesting
if the <code>name</code> argument is set.
</p>
<p>The transaction isolation level is not specified by DBI.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cash", data.frame(amount = 100))
dbWriteTable(con, "account", data.frame(amount = 2000))

# All operations are carried out as logical unit:
dbBegin(con)
withdrawal &lt;- 300
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
dbCommit(con)

dbReadTable(con, "cash")
dbReadTable(con, "account")

# Rolling back after detecting negative value on account:
dbBegin(con)
withdrawal &lt;- 5000
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
if (dbReadTable(con, "account")\$amount &gt;= 0) {
  dbCommit(con)
} else {
  dbRollback(con)
}

dbReadTable(con, "cash")
dbReadTable(con, "account")

dbDisconnect(con)

</code></pre>
<h2 id="dbWithTransaction">Self-contained SQL transactions</h2>

<span id="topic+dbWithTransaction"></span>
<span id="topic+dbBreak"></span>
<p>This section describes the behavior of the following methods:</p>
<pre class="r"><code class="language-R">dbWithTransaction(conn, code, ...)

dbBreak()
</code></pre>
<h3>Description</h3>
<p>Given that transactions are implemented, this function
allows you to pass in code that is run in a transaction.
The default method of <code>dbWithTransaction()</code> calls <code>dbBegin()</code>
before executing the code,
and <code>dbCommit()</code> after successful completion,
or <code>dbRollback()</code> in case of an error.
The advantage is
that you don't have to remember to do <code>dbBegin()</code> and <code>dbCommit()</code> or
<code>dbRollback()</code> – that is all taken care of.
The special function <code>dbBreak()</code> allows an early exit with rollback,
it can be called only inside <code>dbWithTransaction()</code>.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbWithTransaction_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object,
as returned by <code>dbConnect()</code>.</p>
</td>
</tr>
<tr>
<td><code id="dbWithTransaction_+3A_code">code</code></td>
<td>
<p>An arbitrary block of R code.</p>
</td>
</tr>
<tr>
<td><code id="dbWithTransaction_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td>
</tr>
</table>

<h3>Details</h3>
<p>DBI implements <code>dbWithTransaction()</code>, backends should need to override this
generic only if they implement specialized handling.
</p>
<h3>Value</h3>
<p><code>dbWithTransaction()</code> returns the value of the executed code.
</p>
<h3>Failure modes</h3>
<p>Failure to initiate the transaction
(e.g., if the connection is closed
or invalid
or if <code>dbBegin()</code> has been called already)
gives an error.
</p>
<h3>Specification</h3>
<p><code>dbWithTransaction()</code> initiates a transaction with <code>dbBegin()</code>, executes
the code given in the <code>code</code> argument, and commits the transaction with
<code>dbCommit()</code>.
If the code raises an error, the transaction is instead aborted with
<code>dbRollback()</code>, and the error is propagated.
If the code calls <code>dbBreak()</code>, execution of the code stops and the
transaction is silently aborted.
All side effects caused by the code
(such as the creation of new variables)
propagate to the calling environment.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cash", data.frame(amount = 100))
dbWriteTable(con, "account", data.frame(amount = 2000))

# All operations are carried out as logical unit:
dbWithTransaction(
  con,
  {
    withdrawal &lt;- 300
    dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
    dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
  }
)

# The code is executed as if in the current environment:
withdrawal

# The changes are committed to the database after successful execution:
dbReadTable(con, "cash")
dbReadTable(con, "account")

# Rolling back with dbBreak():
dbWithTransaction(
  con,
  {
    withdrawal &lt;- 5000
    dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
    dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
    if (dbReadTable(con, "account")\$amount &lt; 0) {
      dbBreak()
    }
  }
)

# These changes were not committed to the database:
dbReadTable(con, "cash")
dbReadTable(con, "account")

dbDisconnect(con)

</code></pre>
<h2 id="dbGetInfo">Get DBMS metadata</h2>

<span id="topic+dbGetInfo"></span>
<p>This section describes the behavior of the following method:</p>
<pre class="r"><code class="language-R">dbGetInfo(dbObj, ...)
</code></pre>
<h3>Description</h3>
<p>Retrieves information on objects of class DBIDriver,
DBIConnection or DBIResult.
</p>
<h3>Arguments</h3>
<table>
<tr>
<td><code id="dbGetInfo_+3A_dbobj">dbObj</code></td>
<td>
<p>An object inheriting from DBIObject,
i.e. DBIDriver, DBIConnection,
or a DBIResult</p>
</td>
</tr>
<tr>
<td><code id="dbGetInfo_+3A_...">...</code></td>
<td>
<p>Other arguments to methods.</p>
</td>
</tr>
</table>

<h3>Value</h3>
<p>For objects of class DBIDriver, <code>dbGetInfo()</code>
returns a named list
that contains at least the following components:
</p>
<ul>
<li> <p><code>driver.version</code>: the package version of the DBI backend,
</p>
</li>
<li> <p><code>client.version</code>: the version of the DBMS client library.
</p>
</li>
</ul>

<p>For objects of class DBIConnection, <code>dbGetInfo()</code>
returns a named list
that contains at least the following components:
</p>
<ul>
<li> <p><code>db.version</code>: version of the database server,
</p>
</li>
<li> <p><code>dbname</code>: database name,
</p>
</li>
<li> <p><code>username</code>: username to connect to the database,
</p>
</li>
<li> <p><code>host</code>: hostname of the database server,
</p>
</li>
<li> <p><code>port</code>: port on the database server.
It must not contain a <code>password</code> component.
Components that are not applicable should be set to <code>NA</code>.
</p>
</li>
</ul>

<p>For objects of class DBIResult, <code>dbGetInfo()</code>
returns a named list
that contains at least the following components:
</p>
<ul>
<li> <p><code>statatment</code>: the statement used with <code>dbSendQuery()</code> or <code>dbExecute()</code>,
as returned by <code>dbGetStatement()</code>,
</p>
</li>
<li> <p><code>row.count</code>: the number of rows fetched so far (for queries),
as returned by <code>dbGetRowCount()</code>,
</p>
</li>
<li> <p><code>rows.affected</code>: the number of rows affected (for statements),
as returned by <code>dbGetRowsAffected()</code>
</p>
</li>
<li> <p><code>has.completed</code>: a logical that indicates
if the query or statement has completed,
as returned by <code>dbHasCompleted()</code>.
</p>
</li>
</ul>

<h3>Implementation notes</h3>
<p>The default implementation for <code style="white-space: pre;">⁠DBIResult objects⁠</code>
constructs such a list from the return values of the corresponding methods,
<code>dbGetStatement()</code>, <code>dbGetRowCount()</code>,
<code>dbGetRowsAffected()</code>, and <code>dbHasCompleted()</code>.
</p>
<h3>Examples</h3>
<pre class="r"><code class="language-R">
dbGetInfo(RSQLite::SQLite())

</code></pre>
